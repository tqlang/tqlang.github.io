# Low-Level

:::under-construction
:::

Abstractions are made to make the programmer's life easier, symplifying
repedititve or system-dependent tasks.

Sometimes however, it is mandatory to communicate directly with the system.
Embedded and bare-metal development, system programming and better memory
managing are just some examples of why this access is needed.

---
## Acessing CPU Registers

:::not-implemented
:::

When compiled to some CPUs, the program binary has access to a set of CPU
Registers that are used to do operations or controll the CPU behavior.

// TODO

---
## Inline Assembly

:::not-implemented
:::

When read and write to the registers themselves are not enough, Abstract
has a rich system that allow the user to write an entire assembly subroutine.

As a example of use, being targeted to x86_64 assemby:

```tq
from Std.Console import
from Std.System.Assembly import { assemblyContext }

func foo() {

	let string message = "Hello, World!"

	# Calling writeln(message) though assembly

	# This will create the context object.
	# The context object is used to store the
	# entire assembly code in a tiny scope,
	# allowing that the code will be emited as
	# is and do not receive any optimizations.
	assemblyContext()

	# The context return an instance that contains
	# diverse methods to write the assembly code.
	# See the example:

	# The first argument must go in the RDI register
	# the mov instruction follows the order 'to <- from'
	.MOV(.rdi, &message)

	# Then we can make a call to the function
	.CALL(writeln)

	# `.execute()` must be called to the
	# code to take effect.
	.execute()

	#This is equivalent to
	###
		MOV $rax, message
		CALL Std.Console.writeln
	###

}
```

```tq
from Std.Console import
from Std.System.Assembly import { assemblyContext }

func foo() {

	let string message = "Hello, World!"

	# Writing to STDOUT in x86 linux
	assemblyContext()

	.MOV(.eax, 1)           # syscall = write
	.MOV(.rdi, 1)           # descriptor = stdout
	.MOV(.rsi, &message)    # message reference (internally solved to pointer)
	.MOV(.rdx, message.len) # message length
	.SYSCALL()

	.execute()
}
```
