# General-Usage Types
:::under-construction
:::

tq also has some other primitive types that aren't just numbers.
Some of them exists to create some abstractions with complex collections of
numerical values or create type encapsulation.

---
## Booleans

Booleans are types that can only represent the binary values `true` or `false`.
These two values are extremely important to handle conditionals or hold simple
states without messing the values.

```tq
#/// func scope ///
bool    # 1-bit | `true` or `false`
```

```tq
#/// func scope ///
let cake = false

if (cake) Std.Console.writeln("Yummy!")
else Std.Console.writeln("The cake is a lie!")
```
```text title="Console Output"
The cake is a lie!
```

---
## Strings

A string is a data structure that is able to store text data. A string can be
used to store and reproduce text characters easily. \

```tq
#/// func scope ///
string    # variable size (can be heap or statically allocated)
```

```tq
#/// func scope ///
let string mySpeek = "Hello, World!"
Std.Console.writeln(mySpeek)

mySpeek = "Goodbie, World!"
Std.Console.writeln(mySpeek)
```
```text title="Console Output"
Hello, World!
Goodbie, World!
```

In tq, every string is by default encoded in UTF-8, with characters varying from 1-4
bytes in length. To be able to use other encodings, null

---
## Chars
:::not-implemented
:::

Chars are data structures made to hold a single text character. Chars value can
either be set or assigned manually with a character value or it can be set by
getting a character from an index of a string. \
As every string in tq is UTF-8, every character have the same length as a `i32`
in memory, being able to hold every possible character of the Unicode char set.

:::note
Keep in mind that some unicode characters may use more than one character to be stored,
e.g. `"ðŸ‡§ðŸ‡·" = 'ðŸ‡§' + 'ðŸ‡·'`. \
The Char struct cannot store that characters, use a String or a slice of Chars for it!
:::

Chars are be castable from integers lower than 32 bits e.g. `u8`, `i7` or `u32`
and castable to any integer.

```tq
#/// func scope ///
char    # 32-bits | can represent single unicode characters
```
```tq
#/// func scope ///
const string myString = "Hello, World!"

let char myChar = 'U'
myChar = myString[7]
Std.Console.writeln(myChar as byte) # '87'

```

---
## Range
:::not-implemented
:::

Ranges are types with a special syntax and are used widelly though the language.
They can be representd as:
```pseudo
<start>..<finish>:<step>
```
And some values can be implicited, like:
```tq
#/// func scope ///
..10     # from 0 to 10
..10:8   # from 0 to 10, in steps of 8
5..      # from 5 to undefined limit
5..:14   # from 0 to undefined limit, in steps of 14
```

To iterate though a range, get a instance of the range iterator:
```tq
#/// func scope ///
from Std.Console import

const myRange = 0..20 : 2
var iterator = myRange.iterator()

var uint i
while (iterator.reachEnd()) : (i = iterator.next()) {
    writeln(i)
}
```

---
## Void

Void is an abstract type and it is used to indicate that a value is not returned.
```tq
#/// func scope ///
void
```

---
## NoReturn


NoReturn is an abstract type that is used to indicate that a function does not returns.
```tq
#/// func scope ///
noreturn
```
