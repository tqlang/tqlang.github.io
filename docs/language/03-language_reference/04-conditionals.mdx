# Conditionals

:::under-construction
:::

Conditionals are a important aspect of a program, allowing it to do specific behaviors with specific inputs.

The language have 4 main kinds of conditional checking: `if`, `elif` and `else` statements and `match` expressions.

---
## if, elif and else blocks

`if`, `elif` and `else` are the most basic conditional statement.

These statements allows the formation of conditional cascades, checking one
condition after another until one of them is true or the cascade ends.

The condition expression evaluated after the `if` and `elif` keywords needs to be or result in
a `Boolean` type.

If false, the code will jump the next declarated statement and continue the process in the seccond statement
after the condition.

```tq
#/// func scope ///
let sayHello = false

if sayHello
	Std.Console.writeln("Hello, World!")

# This statement is outside the condition!
Std.Console.writeln("Goodbie, World!")
```
```text title="Console Output"
Goodbie, World!
```

When an `elif` statement is declarated after a `if` or `elif`, the condition will be
verified only if the conditions above are evaluated as false.

When an `else` statement is declarated after a `if` or `elif`, the statement will be
executed only when all the above conditions are evaluated as false.

As the condition chain is evaluated from top to bottom, sometimes is possible to
end up with unreachable conditions.

```tq
#/// func scope ///
let i32 value = 10

# First condition evaluated.
# as 10 != 0, it will fall to the next elif
if value == 0
	Std.Console.writeln("value is exactly 0!")

# as 10 != 1, it will fall to the next elif
elif value == 1
	Std.Console.writeln("value is exactly 1!")

# as 10 > 5, it will fall to the next elif
elif value < 5
	Std.Console.writeln("Value is lower than 5 but greater than 1!")

# as 10 == 10, the next statement will be processed
elif value >= 10
	Std.Console.writeln("Value is equal or greater than 10!")

# It's impossible to a number to be greater than 11
# and not be greater than 10. This condition is unreachable.
elif value > 11
	Std.Console.writeln("Value is greater than 11!")

# A new if keyword will start a new conditional cascade
if value == 11
	Std.Console.writeln("Value is exactly 11!")

# If all conditions in the cascade evaluate to false,
# the else statement will aways be processed
else
	Std.Console.writeln("Value is not 11")

```

if more than a statement needs to be executed in case of a condition, it's possible to
open a conde block with brackets (`{ ... }`).

```tq
#/// func scope ///
let i32 value = ...

if (value > 30) Std.Console.writeln("Value is greater than 30!")
elif (value < 30) Std.Console.writeln("Value is lesser than 30!")
else {
	# Here, this entire code block will be executed in case of the
	# value be exactly 30.
	Std.Console.writeln("Certainly,")
	Std.Console.writeln("the value is")
	Std.Console.writeln("exactly 30!")
}

```

---
## Match
:::not-implemented
:::

Value match expressions are great ways to simplify (and very often, optimize) long if-else blocks.
A match expression will test a value against diferent values or conditions and conditionally execute
the code of the matched option. If no valid option matches the provided value, it will fall into a
default fallback option if provided.

```tq
#/// func scope ///
let i32 value = ...

match value {
	case 10     => Std.Console.writeln("value is 10!")
	case 20     => Std.Console.writeln("value is 20!")
	case > 30   => Std.Console.writeln("value is greater than 30!")

	default => Std.Console.writeln("Value is neither 10 or 20, but is less or equal to 30!")
}

# Match blocks can return values too!
let i32 by2 = match value {
	case 10 => 5
	case 20 => 10
	case 30 => 15
	case 40 => 20

	default => value / 2
}
```

When used as statements and with, `match` expressions can implement the behavior of
directily executing another case block, without testing it's condition.
to enable this behavior, use the keyword `continue` with the block case condition
right after it:

```tq
typedef Privilege {
	case notAllowed
	case basic
	case moderator
	case admin
}

func ... {
	let Privilege permissionLevel = ...
	let canSee = false
	let canWrite = false
	let canArchive = false

	match permissionLevel {
		default => {
			Std.Console.writeln("Permission denied!")
			Std.Process.exit(1)
		}

		case .admin     => canArchive = true; continue .moderator
		case .moderator => canWrite = true; continue .basic
		case .basic     => csnSee = true
	}
	Std.Console.writeln("User is \{permissionLevel}")
	Std.Console.writeln("Can See:     \{canSee}")
	Std.Console.writeln("Can Write:   \{canWrite}")
	Std.Console.writeln("Can Archive: \{canArchive}")
}

```
